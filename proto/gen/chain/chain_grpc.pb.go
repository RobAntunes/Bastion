// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.3
// source: chain.proto

package chain

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	BastionService_AddBlock_FullMethodName            = "/chain.BastionService/AddBlock"
	BastionService_GetBlockchain_FullMethodName       = "/chain.BastionService/GetBlockchain"
	BastionService_CreateBlockchain_FullMethodName    = "/chain.BastionService/CreateBlockchain"
	BastionService_GetBlockchainHeight_FullMethodName = "/chain.BastionService/GetBlockchainHeight"
)

// BastionServiceClient is the client API for BastionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BastionServiceClient interface {
	AddBlock(ctx context.Context, in *AddBlockRequest, opts ...grpc.CallOption) (*AddBlockResponse, error)
	GetBlockchain(ctx context.Context, in *GetBlockchainRequest, opts ...grpc.CallOption) (*GetBlockchainResponse, error)
	CreateBlockchain(ctx context.Context, in *CreateBlockchainRequest, opts ...grpc.CallOption) (*CreateBlockchainResponse, error)
	GetBlockchainHeight(ctx context.Context, in *GetBlockchainHeightRequest, opts ...grpc.CallOption) (*GetBlockchainHeightResponse, error)
}

type bastionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBastionServiceClient(cc grpc.ClientConnInterface) BastionServiceClient {
	return &bastionServiceClient{cc}
}

func (c *bastionServiceClient) AddBlock(ctx context.Context, in *AddBlockRequest, opts ...grpc.CallOption) (*AddBlockResponse, error) {
	out := new(AddBlockResponse)
	err := c.cc.Invoke(ctx, BastionService_AddBlock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bastionServiceClient) GetBlockchain(ctx context.Context, in *GetBlockchainRequest, opts ...grpc.CallOption) (*GetBlockchainResponse, error) {
	out := new(GetBlockchainResponse)
	err := c.cc.Invoke(ctx, BastionService_GetBlockchain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bastionServiceClient) CreateBlockchain(ctx context.Context, in *CreateBlockchainRequest, opts ...grpc.CallOption) (*CreateBlockchainResponse, error) {
	out := new(CreateBlockchainResponse)
	err := c.cc.Invoke(ctx, BastionService_CreateBlockchain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bastionServiceClient) GetBlockchainHeight(ctx context.Context, in *GetBlockchainHeightRequest, opts ...grpc.CallOption) (*GetBlockchainHeightResponse, error) {
	out := new(GetBlockchainHeightResponse)
	err := c.cc.Invoke(ctx, BastionService_GetBlockchainHeight_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BastionServiceServer is the server API for BastionService service.
// All implementations must embed UnimplementedBastionServiceServer
// for forward compatibility
type BastionServiceServer interface {
	AddBlock(context.Context, *AddBlockRequest) (*AddBlockResponse, error)
	GetBlockchain(context.Context, *GetBlockchainRequest) (*GetBlockchainResponse, error)
	CreateBlockchain(context.Context, *CreateBlockchainRequest) (*CreateBlockchainResponse, error)
	GetBlockchainHeight(context.Context, *GetBlockchainHeightRequest) (*GetBlockchainHeightResponse, error)
	mustEmbedUnimplementedBastionServiceServer()
}

// UnimplementedBastionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBastionServiceServer struct {
}

func (UnimplementedBastionServiceServer) AddBlock(context.Context, *AddBlockRequest) (*AddBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddBlock not implemented")
}
func (UnimplementedBastionServiceServer) GetBlockchain(context.Context, *GetBlockchainRequest) (*GetBlockchainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockchain not implemented")
}
func (UnimplementedBastionServiceServer) CreateBlockchain(context.Context, *CreateBlockchainRequest) (*CreateBlockchainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBlockchain not implemented")
}
func (UnimplementedBastionServiceServer) GetBlockchainHeight(context.Context, *GetBlockchainHeightRequest) (*GetBlockchainHeightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockchainHeight not implemented")
}
func (UnimplementedBastionServiceServer) mustEmbedUnimplementedBastionServiceServer() {}

// UnsafeBastionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BastionServiceServer will
// result in compilation errors.
type UnsafeBastionServiceServer interface {
	mustEmbedUnimplementedBastionServiceServer()
}

func RegisterBastionServiceServer(s grpc.ServiceRegistrar, srv BastionServiceServer) {
	s.RegisterService(&BastionService_ServiceDesc, srv)
}

func _BastionService_AddBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).AddBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_AddBlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).AddBlock(ctx, req.(*AddBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BastionService_GetBlockchain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockchainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).GetBlockchain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_GetBlockchain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).GetBlockchain(ctx, req.(*GetBlockchainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BastionService_CreateBlockchain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBlockchainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).CreateBlockchain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_CreateBlockchain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).CreateBlockchain(ctx, req.(*CreateBlockchainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BastionService_GetBlockchainHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockchainHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).GetBlockchainHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_GetBlockchainHeight_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).GetBlockchainHeight(ctx, req.(*GetBlockchainHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BastionService_ServiceDesc is the grpc.ServiceDesc for BastionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BastionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chain.BastionService",
	HandlerType: (*BastionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddBlock",
			Handler:    _BastionService_AddBlock_Handler,
		},
		{
			MethodName: "GetBlockchain",
			Handler:    _BastionService_GetBlockchain_Handler,
		},
		{
			MethodName: "CreateBlockchain",
			Handler:    _BastionService_CreateBlockchain_Handler,
		},
		{
			MethodName: "GetBlockchainHeight",
			Handler:    _BastionService_GetBlockchainHeight_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chain.proto",
}

const (
	BlockService_AddTransaction_FullMethodName  = "/chain.BlockService/AddTransaction"
	BlockService_CreateBlock_FullMethodName     = "/chain.BlockService/CreateBlock"
	BlockService_GetPreviousHash_FullMethodName = "/chain.BlockService/GetPreviousHash"
)

// BlockServiceClient is the client API for BlockService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlockServiceClient interface {
	AddTransaction(ctx context.Context, in *AddTransactionRequest, opts ...grpc.CallOption) (*AddTransactionResponse, error)
	CreateBlock(ctx context.Context, in *CreateBlockRequest, opts ...grpc.CallOption) (*CreateBlockResponse, error)
	GetPreviousHash(ctx context.Context, in *GetPreviousHashRequest, opts ...grpc.CallOption) (*GetPreviousHashResponse, error)
}

type blockServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBlockServiceClient(cc grpc.ClientConnInterface) BlockServiceClient {
	return &blockServiceClient{cc}
}

func (c *blockServiceClient) AddTransaction(ctx context.Context, in *AddTransactionRequest, opts ...grpc.CallOption) (*AddTransactionResponse, error) {
	out := new(AddTransactionResponse)
	err := c.cc.Invoke(ctx, BlockService_AddTransaction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockServiceClient) CreateBlock(ctx context.Context, in *CreateBlockRequest, opts ...grpc.CallOption) (*CreateBlockResponse, error) {
	out := new(CreateBlockResponse)
	err := c.cc.Invoke(ctx, BlockService_CreateBlock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockServiceClient) GetPreviousHash(ctx context.Context, in *GetPreviousHashRequest, opts ...grpc.CallOption) (*GetPreviousHashResponse, error) {
	out := new(GetPreviousHashResponse)
	err := c.cc.Invoke(ctx, BlockService_GetPreviousHash_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlockServiceServer is the server API for BlockService service.
// All implementations must embed UnimplementedBlockServiceServer
// for forward compatibility
type BlockServiceServer interface {
	AddTransaction(context.Context, *AddTransactionRequest) (*AddTransactionResponse, error)
	CreateBlock(context.Context, *CreateBlockRequest) (*CreateBlockResponse, error)
	GetPreviousHash(context.Context, *GetPreviousHashRequest) (*GetPreviousHashResponse, error)
	mustEmbedUnimplementedBlockServiceServer()
}

// UnimplementedBlockServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBlockServiceServer struct {
}

func (UnimplementedBlockServiceServer) AddTransaction(context.Context, *AddTransactionRequest) (*AddTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTransaction not implemented")
}
func (UnimplementedBlockServiceServer) CreateBlock(context.Context, *CreateBlockRequest) (*CreateBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBlock not implemented")
}
func (UnimplementedBlockServiceServer) GetPreviousHash(context.Context, *GetPreviousHashRequest) (*GetPreviousHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPreviousHash not implemented")
}
func (UnimplementedBlockServiceServer) mustEmbedUnimplementedBlockServiceServer() {}

// UnsafeBlockServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlockServiceServer will
// result in compilation errors.
type UnsafeBlockServiceServer interface {
	mustEmbedUnimplementedBlockServiceServer()
}

func RegisterBlockServiceServer(s grpc.ServiceRegistrar, srv BlockServiceServer) {
	s.RegisterService(&BlockService_ServiceDesc, srv)
}

func _BlockService_AddTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServiceServer).AddTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlockService_AddTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServiceServer).AddTransaction(ctx, req.(*AddTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockService_CreateBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServiceServer).CreateBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlockService_CreateBlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServiceServer).CreateBlock(ctx, req.(*CreateBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockService_GetPreviousHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPreviousHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockServiceServer).GetPreviousHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BlockService_GetPreviousHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockServiceServer).GetPreviousHash(ctx, req.(*GetPreviousHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BlockService_ServiceDesc is the grpc.ServiceDesc for BlockService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlockService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chain.BlockService",
	HandlerType: (*BlockServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddTransaction",
			Handler:    _BlockService_AddTransaction_Handler,
		},
		{
			MethodName: "CreateBlock",
			Handler:    _BlockService_CreateBlock_Handler,
		},
		{
			MethodName: "GetPreviousHash",
			Handler:    _BlockService_GetPreviousHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chain.proto",
}

const (
	TransactionService_CreateTransaction_FullMethodName = "/chain.TransactionService/CreateTransaction"
)

// TransactionServiceClient is the client API for TransactionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TransactionServiceClient interface {
	CreateTransaction(ctx context.Context, in *AddTransactionRequest, opts ...grpc.CallOption) (*AddTransactionResponse, error)
}

type transactionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTransactionServiceClient(cc grpc.ClientConnInterface) TransactionServiceClient {
	return &transactionServiceClient{cc}
}

func (c *transactionServiceClient) CreateTransaction(ctx context.Context, in *AddTransactionRequest, opts ...grpc.CallOption) (*AddTransactionResponse, error) {
	out := new(AddTransactionResponse)
	err := c.cc.Invoke(ctx, TransactionService_CreateTransaction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TransactionServiceServer is the server API for TransactionService service.
// All implementations must embed UnimplementedTransactionServiceServer
// for forward compatibility
type TransactionServiceServer interface {
	CreateTransaction(context.Context, *AddTransactionRequest) (*AddTransactionResponse, error)
	mustEmbedUnimplementedTransactionServiceServer()
}

// UnimplementedTransactionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTransactionServiceServer struct {
}

func (UnimplementedTransactionServiceServer) CreateTransaction(context.Context, *AddTransactionRequest) (*AddTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTransaction not implemented")
}
func (UnimplementedTransactionServiceServer) mustEmbedUnimplementedTransactionServiceServer() {}

// UnsafeTransactionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TransactionServiceServer will
// result in compilation errors.
type UnsafeTransactionServiceServer interface {
	mustEmbedUnimplementedTransactionServiceServer()
}

func RegisterTransactionServiceServer(s grpc.ServiceRegistrar, srv TransactionServiceServer) {
	s.RegisterService(&TransactionService_ServiceDesc, srv)
}

func _TransactionService_CreateTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).CreateTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransactionService_CreateTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).CreateTransaction(ctx, req.(*AddTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TransactionService_ServiceDesc is the grpc.ServiceDesc for TransactionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TransactionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chain.TransactionService",
	HandlerType: (*TransactionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTransaction",
			Handler:    _TransactionService_CreateTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chain.proto",
}

const (
	EntropyService_GetEntropy_FullMethodName = "/chain.EntropyService/GetEntropy"
)

// EntropyServiceClient is the client API for EntropyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EntropyServiceClient interface {
	GetEntropy(ctx context.Context, in *GetEntropyRequest, opts ...grpc.CallOption) (*GetEntropyResponse, error)
}

type entropyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEntropyServiceClient(cc grpc.ClientConnInterface) EntropyServiceClient {
	return &entropyServiceClient{cc}
}

func (c *entropyServiceClient) GetEntropy(ctx context.Context, in *GetEntropyRequest, opts ...grpc.CallOption) (*GetEntropyResponse, error) {
	out := new(GetEntropyResponse)
	err := c.cc.Invoke(ctx, EntropyService_GetEntropy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EntropyServiceServer is the server API for EntropyService service.
// All implementations must embed UnimplementedEntropyServiceServer
// for forward compatibility
type EntropyServiceServer interface {
	GetEntropy(context.Context, *GetEntropyRequest) (*GetEntropyResponse, error)
	mustEmbedUnimplementedEntropyServiceServer()
}

// UnimplementedEntropyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedEntropyServiceServer struct {
}

func (UnimplementedEntropyServiceServer) GetEntropy(context.Context, *GetEntropyRequest) (*GetEntropyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEntropy not implemented")
}
func (UnimplementedEntropyServiceServer) mustEmbedUnimplementedEntropyServiceServer() {}

// UnsafeEntropyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EntropyServiceServer will
// result in compilation errors.
type UnsafeEntropyServiceServer interface {
	mustEmbedUnimplementedEntropyServiceServer()
}

func RegisterEntropyServiceServer(s grpc.ServiceRegistrar, srv EntropyServiceServer) {
	s.RegisterService(&EntropyService_ServiceDesc, srv)
}

func _EntropyService_GetEntropy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEntropyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntropyServiceServer).GetEntropy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EntropyService_GetEntropy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntropyServiceServer).GetEntropy(ctx, req.(*GetEntropyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EntropyService_ServiceDesc is the grpc.ServiceDesc for EntropyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EntropyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chain.EntropyService",
	HandlerType: (*EntropyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEntropy",
			Handler:    _EntropyService_GetEntropy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chain.proto",
}
